/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

IfxCpu_syncEvent g_cpuSyncEvent = 0;

/* MACRO DEFINE START */
// GPIO input channel
#define P10_IOCR0_BASE 0xF003B010

#define PC0_BIT_LSB_IDX         3
#define PC1_BIT_LSB_IDX         11
#define PC2_BIT_LSB_IDX         19
#define PC3_BIT_LSB_IDX         27
#define PC5_BIT_LSB_IDX         11
#define PC7_BIT_LSB_IDX         27
#define P1_BIT_LSB_IDX          1
#define P2_BIT_LSB_IDX          2
#define P3_BIT_LSB_IDX          3
#define P5_BIT_LSB_IDX          5
#define P7_BIT_LSB_IDX          7

// SCU_EICR register
#define EXIS0_BIT_LSB_IDX 4
#define FEN0_BIT_LSB_IDX 8
#define EIEN0_BIT_LSB_IDX 11
#define INP0_BIT_LSB_IDX 12

// SCU_IGCR register
#define IGP0_BIT_LSB_IDX 14

// SCUERU register
#define SRPN_BIT_LSB_IDX 0
#define SRE_BIT_LSB_IDX 10
#define TOS_BIT_LSB_IDX 11

// etc
#define UNBOUNCE_TIME 100
/* MACRO DEFINE END */

unsigned char cur_mode = 0x0;

void initLED(void){
    P10_IOCR0.U &= ~(0x1F << PC1_BIT_LSB_IDX); /* clear P10_IOCR0.PC1 */
    P10_IOCR0.U &= ~(0x1F << PC2_BIT_LSB_IDX); /* clear P10_IOCR0.PC2 */

    P10_IOCR0.U |= (0x10 << PC1_BIT_LSB_IDX); /* P10.1(D12) -> output mode */
    P10_IOCR0.U |= (0x10 << PC2_BIT_LSB_IDX); /* P10.2(D13) -> output mode */
}

void initRGBLED(void){
    // reset port IOCR register
    P02_IOCR4.U &= ~(0x1F << PC7_BIT_LSB_IDX); /* clear P02_IOCR4.PC7 */
    P10_IOCR0.U &= ~(0x1F << PC3_BIT_LSB_IDX); /* clear P10_IOCR0.PC2 */
    P10_IOCR4.U &= ~(0x1F << PC5_BIT_LSB_IDX); /* clear P10_IOCR0.PC2 */

    // set port as general purpose output
    P02_IOCR4.U |=  (0x10 << PC7_BIT_LSB_IDX); /* P02.7(D9) -> output mode */
    P10_IOCR0.U |=  (0x10 << PC3_BIT_LSB_IDX); /* P10.3(D10) -> output mode */
    P10_IOCR4.U |=  (0x10 << PC5_BIT_LSB_IDX); /* P10.5(D11) -> output mode */
}


void initBTN(void){
    P02_IOCR0.U &= ~(0x1F << PC1_BIT_LSB_IDX); /* clear P2_IOCR0.PC0 */
    P02_IOCR0.U |= (0x02 << PC1_BIT_LSB_IDX); /* P02.1(D3) -> general input mode(pull-up) */
}

void initERU(void){
    /* ERU Interrupt Setting */
    // ERS channel 2의  4개 External Request 입력 중, 두번째 인덱스 선택 , -> ln21
    SCU_EICR1.U &= ~(0x7 << EXIS0_BIT_LSB_IDX); /* clear SCU_EICR1_EXIS */
    SCU_EICR1.U |= (0x1 << EXIS0_BIT_LSB_IDX); /* SCU_EICR1_EXIS0 -> ERS2_ln21 */

    // Interrupt 발생 조건을 Input Channel의 입력신호 rising/falling edge 감지하도록 설정 -> falling edge
    SCU_EICR1.U |= (0x1 << FEN0_BIT_LSB_IDX); /* SCU_EICR1_FEN0 -> falling edge detection */

    // falling edge 발생시 Trigger 신호 발생 enable
    SCU_EICR1.U |= (0x1 << EIEN0_BIT_LSB_IDX); /* SCU_EICR1_EIEN0 -> trigger generate enabled */

    // 생성되는 Trigger 신호를 OGU를 통해 Interrupt 신호로 내보내기 위해 OGU0로 전송
    SCU_EICR1.U &= ~(0x7 << INP0_BIT_LSB_IDX); /* SCU_EICR_INP0 -> trigger output to OGU0 */

    // OGU에서 입력받은 Trigger 신호를 ERU의 IOUT 포트로 출력하도록 설정.
    SCU_IGCR0.U &= ~(0x3 << IGP0_BIT_LSB_IDX); /* clear SCU_IGCR0_IGP0 */
    SCU_IGCR0.U |= (0x1 << IGP0_BIT_LSB_IDX); /* SCU_IGCR0_IGP0 -> output is activated(response to trigger) */

    /* SRC Interrupt Setting */
    // IOUT interrupt SRC_SCUERU0.
    // SRC_SCUERU0 priority
    SRC_SCUERU0.U &= ~(0xFF << SRPN_BIT_LSB_IDX); /* clear Service Request Priority Number */
    SRC_SCUERU0.U |= (0x0A << SRPN_BIT_LSB_IDX); /* Service Request Priority Number -> 10 */

    SRC_SCUERU0.U &= ~(0x03 << TOS_BIT_LSB_IDX); /* CPU0 service is initiated */

    SRC_SCUERU0.U |= (0x1 << SRE_BIT_LSB_IDX); /* Service Request Enabled */
}

// priority 10으로 설정, cpu0을 이용하도록 설정
__interrupt(0x0A) __vector_table(0) /* IGNORE WARNING IN VS CODE! */
void ERU0_ISR(void){
    cur_mode ^= 1<<0;

    switch (cur_mode)
    {
    case 0x0:   // Manual, RGB OFF
        P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
        P10_OUT.U &= ~(0x1 << P3_BIT_LSB_IDX);
        P10_OUT.U &= ~(0x1 << P5_BIT_LSB_IDX);
        break;
    case 0x1:   // SMART, GREEN
        P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
        P10_OUT.U &= ~(0x1 << P3_BIT_LSB_IDX);
        P10_OUT.U |= (0x1 << P5_BIT_LSB_IDX);
        break;
    
    default:
        break;
    }
}

int core0_main(void)
{
    IfxCpu_enableInterrupts();

    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    initLED();  /* configure P10.1, P10.2 -> output mode */
    initRGBLED();
    initBTN();  /* configure P2.1 -> general input mode(pull-up) */
    initERU();  /* init Interrupt Module */

    while(1)
    {
    }

    return (1);
}
